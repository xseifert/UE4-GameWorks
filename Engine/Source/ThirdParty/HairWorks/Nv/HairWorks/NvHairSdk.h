/* Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.
* NVIDIA CORPORATION and its licensors retain all intellectual property
* and proprietary rights in and to this software, related documentation
* and any modifications thereto.  Any use, reproduction, disclosure or
* distribution of this software and related documentation without an express
* license agreement from NVIDIA CORPORATION is strictly prohibited. */

#ifndef NV_HAIR_SDK_H
#define NV_HAIR_SDK_H

/* --------------------------------------------------------------------------
                                   HairWorks                                 
-----------------------------------------------------------------------------

NVIDIA HairWorks enables users to simulate and render fur/hair to provide a 
truly interactive game experience. The technology originates from multiple 
simulation and rendering technologies that NVIDIA has developed in the past. 
This combines rendering technologies for human hair (GDC 2008) as well as 
various simulation technologies shown in multiple events (Fur Demo - GDC2012).

To make the hair/fur technologies a product, NVIDIA engineers have put
together these existing technologies and added new techniques to ensure a 
smooth pipeline for a variety of characters.

-----------------------------------------------------------------------------
                             INTEGRATION EXAMPLE                             
-----------------------------------------------------------------------------

This is an overview of the integration. Please refer to the API documentation
in the header file and the sample code for details.  

HairWorks uses an external library 'NvCommon' for basic functionality. Headers from the library are 
prefixed with NvCo, and the types are in the nvidia::Common (NvCo for short)
namespace.

(1.) LOAD THE LIBRARY

	// Allows wrapping of Dx11 types so they can be passed in and out of the sdk
	#include <Nv/Common/Platform/Dx11/NvCoDx11Handle.h>
	// HairWorks main header file
	#include <Nv/HairWorks/NvHairSdk.h> 
	// Optional header that allows easy loading of the dll
	#include <Nv/HairWorks/Platform/Win/NvHairWinLoadSdk.h>

	NvHair::Sdk* hairSdk = NvHair::loadHairSdk("NvHairWorksDx11.win64.dll", NV_HAIR_VERSION);

(2.) INITIALIZE

Initialize D3D Device.

	hairSdk->initRenderResources(NvCo::Dx11Type::wrap(d3dDevice));

Create the hair asset manually from your asset data

	NvHair::AssetDescriptor desc;
	desc.m_numGuideHairs = 4;
	desc.m_numVertices = 20;
	desc.m_vertices = vertices;
	desc.m_endIndices = endIndices;
	desc.m_bindPoses = bindPoses;
	desc.m_boneParents = boneParents;
	...
	hairSdk->createAsset(desc, &hairAssetId);

Or load it from the .apx file (generated by DCC tool or FurViewer) using the API.
	
	#include <Nv/Common/Platform/StdC/NvCoStdCFileReadStream.h>


	NvHair::AssetId assetId;

	NvCo::StdCFileReadStream stream("test.apx");
	hairSdk->loadAsset(stream, assetId);

Create a hair instance from the hair asset.

	NvHair::InstanceId instanceId;
	hairSdk->createInstance(assetId, instanceId);

(3.) SIMULATION/RENDERING

Set render context for HairWorks.

	hairSdk->setCurrentContext(NvCo::Dx11Type::wrap(d3dContext));

Update descriptor parameters for each hair instance.

	NvHair::InstanceDescriptor desc;
	desc.m_width = 0.2;
	desc.m_density = 1.0;
	desc.m_lengthNoise = 0.0f;
	desc.m_simulate = true;
	...
	hairSdk->updateInstanceDescriptor(instanceId, desc);

Update skinning matrices for each hair
	hairSdk->updateSkinningMatrices(instanceId, numBones, matrices); 

Run simulation for all hairs.

	hairSdk->stepSimulation(elapsedTime);

Set view matrix and projection matrix.

	D3DXMATRIX projection = camera.getProjectionMatrix();
	D3DXMATRIX view = camera.getViewMatrix();
	hairSdk->setViewProjection((const Mat4x4*)&view,(const Mat4x4*)&projection);

Set your hair pixel shader before rendering hairs.

	pd3dContext->PSSetShader(g_customHairWorksShader, NV_NULL, 0);

Render each hair instance.

	hairSdk->renderHairs(instanceId);

(4.) RELEASE

	hairSdk->freeInstance(instanceId);
	hairSdk->freeAsset(assetId);
	hairSdk->freeRenderResources();
	hairSdk->release();
*/

#include "NvHairCommon.h"

#include <Nv/Common/NvCoMemoryAllocator.h>
#include <Nv/Common/NvCoTypeMacros.h>
#include <Nv/Common/NvCoLogger.h>
#include <Nv/Common/NvCoStream.h>

#include <Nv/Common/NvCoApiHandle.h>

/** \defgroup HairWorks HairWorks Sdk
@{
*/

namespace nvidia {
namespace HairWorks {
/*! \namespace nvidia::HairWorks
\brief Main HairWorks SDK namespace
\details The nvidia::HairWorks namespace, holds the majority of the types, classes and methods of the SDK. Types in the
namespace can be referenced either with nvidia::HairWorks, but often it is easier and more readable to use
the the shortened namespace alias NvHair.
*/

/*! Version numbers are encoded as strings as
major.minor.point 
When encoded into a number the last digit plus one is the minor version, and the last digit the point index.
From this the minor and point indices can only be single digit. 

Ie
10.7.4	= 1074 
11.0.0	= 1100

When converting to text, will drop trailing 0 version numbers.
1100 -> "11"
1110 -> "11.1"
1111 -> "11.1.1"
1101 -> "11.0.1"
*/

#define NV_HAIR_VERSION 140				// Versions for Dll BINARY compatibility 
#define NV_HAIR_RELEASE_VERSION 140		// The release version, must be equal or greater than NV_HAIR_VERSION

/*! The version number of serial files. Can be less than or equal to the NV_HAIR_RELEASE_VERSION. 
If a serialization change is made, it should be set to the NV_HAIR_RELEASE_VERSION the change corresponds to. 
NOTE An implementation may be able to load prior versions */
#define NV_HAIR_SERIAL_VERSION 120

/*! release version as a string. NOTE! May contain text after version number */
#define NV_HAIR_RELEASE_VERSION_STRING "1.4 beta"

// Macro to generate a version number 
#define NV_HAIR_MAKE_VERSION(major, minor, point) ((major * 100) + (minor * 10) + point)

struct BuildInfo
{
		/// A buffer large enough to hold string
	enum { VERSION_BUFFER_SIZE = 16 };

		/// A function that can convert strings to version numbers.
	typedef Int(*StringToVersionFunc)(const Char* in);
		/// Function that turns a version number to a major.minor.point format. Returns the number of characters in a string NOT including terminating \0.
	typedef Int(*VersionToStringFunc)(Int version, Char* out);

	Int m_version;				///< The dll version - dll must match this number for binary compatibility
	Int m_serialVersion;		///< The serialize version number
	Int m_releaseVersion;		///< The release version number - must be greater than or equal to m_version
	const Char* m_buildString;	///< String providing information about the build

	StringToVersionFunc m_stringToVersionFunc;	///< A function for converting string to version numbers
	VersionToStringFunc m_versionToStringFunc;
};

/*! \brief Identifier for hair asset data.
	\details The asset id is assigned by HairWorks SDK, and corresponds to a unique asset type.
	\see Sdk.loadAsset() */
enum AssetId
{
	ASSET_ID_NULL = 0xFFFF	//!< invalid hair asset ID
};

/*! \brief Identifier for a hair instance
	\details Multiple hair instances can be created from a single asset type.  
	\see Sdk.createInstance() and Sdk.freeInstance() */
enum InstanceId
{
	INSTANCE_ID_NULL = 0xFFFF //!< invalid hair instance ID
};

/*! Error code for all Sdk functions. Any changes in this list
should be reflected in changes to NV_HAIR_RESULT_OK and NV_HAIR_RESULT_FAIL x macros */
class SubResult { SubResult(); public: enum Enum
{ 
	OK,						///< succeeded
	FAIL,					///< unknown failure
	OPEN_FAILED,			///< file or stream open(or write) failed
	INVALID_PARAMETERS,		///< invalid options to the method
	INVALID_FORMAT,			///< invalid file or memory format
	VERSION_MISMATCH,		///< not supported version
}; };
typedef SubResult::Enum ESubResult;

#define NV_HAIR_RESULT_OK(x) x(OK)
#define NV_HAIR_RESULT_FAIL(x) x(FAIL) x(OPEN_FAILED) x(INVALID_PARAMETERS) x(INVALID_FORMAT) x(VERSION_MISMATCH)

// The facility associated with this type
#define NV_FACILITY_HAIR_WORKS	(NV_FACILITY_EXTERNAL_BASE + 1)

#define NV_HAIR_EXPAND_OK(x) RESULT_##x = NV_MAKE_RESULT(NV_SEVERITY_SUCCESS, NV_FACILITY_HAIR_WORKS, SubResult::x),
#define NV_HAIR_EXPAND_FAIL(x) RESULT_##x = NV_MAKE_RESULT(NV_SEVERITY_ERROR, NV_FACILITY_HAIR_WORKS, SubResult::x),

/*! All of the results for this facility. Can cast a result to NvHair::FacilityResult to quickly see the result */
enum FacilityResult
{
	NV_HAIR_RESULT_OK(NV_HAIR_EXPAND_OK)
	NV_HAIR_RESULT_FAIL(NV_HAIR_EXPAND_FAIL)
};

#define NV_HAIR_RESULT(x) ::NvResult(::NvHair::RESULT_##x)

// Success
#define NV_S_HAIR_OK NV_OK
// Define errors 
#define NV_E_HAIR_FAIL					::NvHair::RESULT_FAIL
#define NV_E_HAIR_OPEN_FAILED			::NvHair::RESULT_OPEN_FAILED
#define NV_E_HAIR_INVALID_PARAMETERS	::NvHair::RESULT_INVALID_PARAMETERS
#define NV_E_HAIR_INVALID_FORMAT		::NvHair::RESULT_INVALID_FORMAT
#define NV_E_HAIR_VERSION_MISMATCH		::NvHair::RESULT_VERSION_MISMATCH

/*! A method that converts an arbitrary Result, as returned from many methods in the API into a SubResult. Any success will be 
returned as SubResult::OK, any unknown failure as SubResult::FAIL */
NV_FORCE_INLINE ESubResult getSubResult(Result res)
{
	if (NV_SUCCEEDED(res)) 
	{
		return SubResult::OK;
	}
	return (NV_GET_RESULT_FACILITY(res) == NV_FACILITY_HAIR_WORKS) ? ESubResult(NV_GET_RESULT_CODE(res)) : SubResult::FAIL;
}

///maximum allowed size for name string
#define NV_HAIR_MAX_STRING 128 

/*! \brief Coordinate system setting for file import and camera view projection
\details Handedness of coordinate system may affect internal HairWorks computation dependent on camera such as culling and shading */
class HandednessHint { HandednessHint();  public: enum Enum
{
	UNKNOWN,	//!< don't know the handedness, use best guess.
	RIGHT,		//!< uses a right handed system (Z is pointing toward the viewer)
	LEFT,		//!< uses a left handed system ( Z is pointing away from the viewer)
	COUNT_OF,
}; };
typedef HandednessHint::Enum EHandednessHint;

/*! \brief Up axis setting of the asset
\details When up axis is different between original DCC tool and HairWorks runtime, provide this info to the file loading APIs.
\see AssetDescriptor, ConversionSettings */
class AxisHint { AxisHint(); public: enum Enum
{
	UNKNOWN,	//!< don't know the up axis, use best guess.
	Y_UP,		//!< camera is y-up
	Z_UP,		//!< camera is z-up
	COUNT_OF,
}; };
typedef AxisHint::Enum EAxisHint;

/*! \brief HairWorks file header
	\details Contains info about this file.
	\note If the version is matched, Sdk.loadAsset() fails. */
struct AssetHeaderInfo
{
	NV_CO_DECLARE_CLASS_BASE(AssetHeaderInfo);

	enum { MAX_STRING_LENGTH = 1024 };

	Int m_serialVersion;					//!< The serial version number. If set to -1 on save will save in current version number.
	Char m_toolVersion[MAX_STRING_LENGTH];	//!< tool version
	Char m_sourcePath[MAX_STRING_LENGTH];	//!< source asset path
	Char m_authorName[MAX_STRING_LENGTH];	//!< author name
	Char m_lastModified[MAX_STRING_LENGTH]; //!< last modified date and time in format "YYYY-MM-DD HH:MM:SS"

	AssetHeaderInfo()
	{
		m_serialVersion = -1;				
		m_toolVersion[0] = '\0';
		m_sourcePath[0] = '\0';
		m_authorName[0] = '\0';
		m_lastModified[0] = '\0';
	}
};

/*! \brief Describes each collision sphere attached to a bone
	\details To enable collision handling between sphere and/or capsule and hair curves, we define a 'boneSphere',
		a sphere whose center is attached to one of the bones used for skinning hairs.
		One can assign radius as well as initial offset with regard to the bind pose of the attached bone. */
struct BoneSphere
{
	UInt32	m_boneSphereIndex;			//!< index for the bone where the collision sphere is attached to
	Float32	m_boneSphereRadius;			//!< radius for the collision sphere
	Vec3    m_boneSphereLocalPos;	//!< offset value with regard to bind position of the bone
};

/*! \brief Descriptor to control properties of pin
	\note for compatibility of older version of apx file, the names of three properties corresponding with m_boneIndex,
	m_radius and m_localPos are still boneSphereIndex, boneSphereRadius, boneSphereLocalPos in new version of apx file.*/
struct Pin
{
	UInt32			m_boneIndex;				//!< index for the bone where the pin is attached to
	Float32			m_radius;					//!< radius of the sphere the pin influence on
	Vec3			m_localPos;					//!< offset value with regard to bind position of the bone
	Float32			m_pinStiffness;				//!< [0 - 1.0] stiffness for pin constraints
	Float32			m_influenceFallOff;			//!< [0 - 1.0] how soft/hard the fall off of the hair pin zone of influence is
	Bool			m_useDynamicPin;			//! [true/false] whether to turn on/off dynamic pin
	Bool			m_useStiffnessPin;			//! [true/false] whether to turn on/off global stiffness on pin
	Bool			m_doLra;					//! [true/false] whether to turn on/off LRA pin
	Bool			m_selected;					//! [true/false] whether this pin is selected

	Vec4			m_influenceFallOffCurve;	//! [0 - 1.0] curve values for influence fall off

	Pin() :
		m_boneIndex(0),
		m_radius(0),
		m_pinStiffness(1.0f),
		m_influenceFallOff(1.0f),
		m_useDynamicPin(false),
		m_useStiffnessPin(true),
		m_doLra(false),
		m_selected(false)
	{
		NvCo::setZero(m_localPos);
		NvCo::setAll(m_influenceFallOffCurve, 1.0f);
	}
};

/*!\brief Descriptor to specify hair asset (hair curves, growth mesh, skinning weights, bone info...)

	\details Hair assets are defined in memory with this data structure, and comprises important part of the hair asset data (.apx) file format.
	This structure defines a minimal static data needed to create hairs in HairWorks.
	A minimal hair assets consists of guide curve data typically exported from DCC tools, and growth mesh face index/uv data.
	Note that vertices of the growth mesh are required to match the root positions of hair guide curves, 
	so it is automatically derived from the curve data without being explicitly stored in the data structure.
	The skinning information (bone index, weight) is derived from that of the growth mesh, and we use skinning info
	to compute target (skinned) positions for each guide hair.  Same bone index/weights are used for CVs of each guide hair.

	\note When the data is invalid, NvHair::Sdk.loadAsset() rejects the hair asset.
	\see All dynamic parameters per hair instance are defined in InstanceDescriptor. 
	\note for compatibility of older version of apx file, the names of two properties corresponding with m_numPins
	and m_pins are still numPinConstraints, pinConstraints in new version of apx file.*/
struct AssetDescriptor
{
	NV_CO_DECLARE_CLASS_BASE(AssetDescriptor);

	Int32			m_numGuideHairs;//!< number of hair guide hair curves
	Int32			m_numVertices;	//!< total # of cv(control vertices) in guide curves
	Vec3*			m_vertices;		//!< all the cv positions of guide curves
	UInt32*			m_endIndices;	//!< index of last vertex for each hair curve pointing to the m_vertices array
									//!< size of this array should be 'm_numGuideHairs'	

	Int32			m_numFaces;		//!< number of hair triangles, we grow hairs for each mesh triangles
	UInt32*			m_faceIndices;	//!< triangle indices for hair faces, size must be 3 * m_numFaces
	Vec2*			m_faceUvs;		//!< uv values for hair faces, size must be 3 * m_numFaces

	Int32			m_numBones;		//!< number of bones used to skin hair curves
	Vec4*			m_boneIndices;	//!< size should be 'm_numGuideHairs'. each mesh vertex (hair root) can have up to 4 bone indices.
	Vec4*			m_boneWeights;	//!< size should be 'm_numGuideHairs'. each mesh vertex (hair root) can have up to 4 bone weights.

	Char*			m_boneNames;	//!<[OPTIONAL] names for each bone used to check if bone names match. buffer size should be at least NV_HAIR_MAX_STRING * 'm_numBones'.
	Mat4x4*			m_bindPoses;	//!<[OPTIONAL] bind pose matrices for each bone. buffer size should be at least sizeof(Mat4x4) * m_numBones.
	Int32*			m_boneParents;	//!<[OPTIONAL] parent index for each bone.  if this is a root bone, the index will be -1. buffer size should be at least sizeof(Nv::Int32) * m_numBones.

	Int32			m_numBoneSpheres;//!< [OPTIONAL] collision spheres used for collision handling between body and hair 
	BoneSphere*		m_boneSpheres;	//!< [OPTIONAL] collision sphere data, each sphere is attached to a bone. The size of this array should be m_numBoneSpheres.
	Int32			m_numBoneCapsules; //!< [OPTIONAL] capsules are defined by connecting a pair of collision spheres
	UInt32*			m_boneCapsuleIndices; //!< [OPTIONAL] index to the bone spheres, size of this array must be 2 * m_numBoneCapsules;

	UInt32			m_numPins;		//!< [OPTIONAL] spheres used to apply soft constraint to pin hairs around the spheres.
	Pin*			m_pins;			//!< [OPTIONAL] constraint sphere data, each sphere is attached to a bone. The size of this array should be m_numPins.

	Char*			m_textureNames;	//!< [OPTIONAL] placeholder to load hair texture file names from apx file. The size must be NV_HAIR_MAX_STRING * NvHair::TextureType::COUNT_OF

	Float32			m_sceneUnit;	//!< scene unit scale in centimeters used in the tool that generated this asset. Centimeter (default): 1.0, Meter: 100.0, Inch: 2.54, Decimeter: 10.0

	EHandednessHint m_handedness; //!< handedness of coordinate system this asset used at time of creation/conversion.  See HandednessHint.
	EAxisHint		m_upAxis;		//!< up axis of coordinate system this asset used at time of creation/conversion.  See AxisHint.
	
	AssetDescriptor() :
		m_numGuideHairs(0),
		m_numVertices(0),		
		m_vertices(NV_NULL),
		m_endIndices(NV_NULL),

		m_numFaces(0),
		m_faceIndices(NV_NULL),
		m_faceUvs(NV_NULL),

		m_numBones(0),
		m_boneIndices(NV_NULL),
		m_boneWeights(NV_NULL),
		m_boneNames(NV_NULL),
		m_bindPoses(NV_NULL),
		m_boneParents(NV_NULL),

		m_numBoneSpheres(0),
		m_boneSpheres(NV_NULL),
		m_numBoneCapsules(0),
		m_boneCapsuleIndices(NV_NULL),

		m_numPins(0),
		m_pins(NV_NULL),

		m_textureNames(NV_NULL),

		m_sceneUnit(1.0f),
	
		m_handedness(HandednessHint::UNKNOWN),
		m_upAxis(AxisHint::UNKNOWN)
	{
	}
};

/*! \brief copy settings for asset import */
struct AssetCopySettings
{
	NV_CO_DECLARE_CLASS_BASE(AssetCopySettings);

	Bool m_copyGroom;
	Bool m_copyCollision;
	Bool m_copyTextures;
	Bool m_copyConstraints;
	Bool m_copyAll;

	AssetCopySettings():
		m_copyAll(true),
		m_copyGroom(true),
		m_copyCollision(true),
		m_copyTextures(true),
		m_copyConstraints(true)
	{
	}
};

/*! \brief Texture types used for hair control textures
\details Some parameters for hair shape/shading/simulation can be controlled with more detail by textures.
Most of these textures are sampled based on (U,V) values derived from the growth mesh.
It is OK to share same texture resource for multiple texture type.
Most of textures have a corresponding constant value, and its value gets used as a multiplier to sampled texture values.
\see Sdk.setTexture() */
class TextureType { TextureType(); public: enum Enum
{
	DENSITY,		///< hair density map [ shape control ]
	ROOT_COLOR,		///< color at the hair root [ shading ]
	TIP_COLOR,		///< color at the hair tip [ shading ]
	WIDTH,			///< width  [ shape control ]
	STIFFNESS,		///< stiffness control [ simulation ]
	ROOT_STIFFNESS, ///< stiffness control for root stiffness [simulation]
	CLUMP_SCALE,	///< clumpiness control [ shape control]
	CLUMP_ROUNDNESS,///< clumping noise [ shape control]
	WAVE_SCALE,		///< waviness scale [ shape control ]
	WAVE_FREQ,		///< waviness frequency [ shape control ]
	STRAND,			///< texture along hair strand [ shading ]
	LENGTH,			///< length control [shape control] 
	SPECULAR,		///< specularity control [shading ] 
	WEIGHTS,		///< weight texture for multiple material blending [control for all other textures]
	COUNT_OF,
}; };
typedef TextureType::Enum ETextureType;

/*! \brief Texture channel for each control textures
\details For a single-channel control textures, one can pack multiple control textures into a single texture resource.
When such packing is used, assign channel for each control texture type. */
class TextureChannel { TextureChannel(); public: enum Enum
{
	RED,
	GREEN,
	BLUE,
	ALPHA
}; };
typedef TextureChannel::Enum ETextureChannel;

class ShaderResourceType { ShaderResourceType(); public: enum Enum 
{
	HAIR_INDICES,			///< face to hair index buffer
	TANGENTS,				///< hair tangent buffer for master strands
	NORMALS,				///< hair normal buffer for master strands
	MASTER_POSITIONS,		///< position for master strand
	PREV_MASTER_POSITIONS,	///< previous position for master strands
	COUNT_OF,
}; };
typedef ShaderResourceType::Enum EShaderResourceType;

/*! \brief Blend mode for strand texture.
\details When the strand texture is used, the blend mode determines how colors should combine between the strand texture and other color textures (root, tip, etc.) */
class StrandBlendMode { StrandBlendMode(); public: enum Enum
{
	OVERWRITE,	///< overwrite with strand texture
	MULTIPLY,	///< multiply strand texture to base color (root/tip)
	ADD,		///< add strand color on top of base color
	MODULATE,	///< add/subtract strand color to/from base color
	COUNT_OF
}; };
typedef StrandBlendMode::Enum EStrandBlendMode;

/*! \brief Colorize option for hair
\details Different options for colorizing hairs for visualization. */
class ColorizeMode { ColorizeMode(); public: enum Enum 
{
	NONE,		///< None
	LOD,		///< colorize lod factors
	TANGENTS,	///< colorize hair tangents
	NORMAL,		///< colorize hair growth mesh normal
	RED,		///< just constant red color for debugging
	COUNT_OF,
}; };
typedef ColorizeMode::Enum EColorizeMode;

/*! \brief Specifies the available serialization formats */
class SerializeFormat { SerializeFormat(); public: enum Enum
{
	UNKNOWN,		///< Format could not be determined
	XML,			///< XML text/human readable format
	BINARY,			///< Binary format
	COUNT_OF,
}; };
typedef SerializeFormat::Enum ESerializeFormat;

/*! \brief Teleport mode
\details Options for teleport control in updateSkinningMatrices. */
class TeleportMode { TeleportMode(); public: enum Enum
{
	NONE,					///< no teleport (keep simulating)
	WITH_SKINNED_POSITION,	///< teleport and set simulation state to skinned position
	COUNT_OF,
}; };
typedef TeleportMode::Enum ETeleportMode;

/*! \brief Descriptor to control all aspects of hair (can be updated and animated per fame)
	\details HairWorks provides a unified parameter control for shape, simulation and rendering through InstanceDescriptor.
		These parameters can be updated using Sdk.updateInstanceDescriptor() between function calls to render or simulations.
	\note Some parameters are length/scale dependent, and all our default values are optimized for CENTIMETERS.
		If the hair scene uses different unit, all unit dependent parameters can be automatically scaled when InstanceDescriptor.m_unitInCentimeters is set correspondingly. */
struct InstanceDescriptor
{
	NV_CO_DECLARE_CLASS_BASE(InstanceDescriptor);

	// global controls
	Bool		m_enable;					//!< [true/false] whether to enable this hair. When disabled, hair will not cause any computation/rendering

	// hair geometry (density/width/length/clump) controls
	Float32		m_width;					//!< [In Millimeters] hair width (thickness)
	Float32		m_widthNoise;				//!< [0 - 1.0] noise factor for hair width noise 
	Float32		m_widthRootScale;			//!< [0 - 1.0] scale factor for top side of the strand
	Float32		m_widthTipScale;			//!< [0 - 1.0] scale factor for bottom side of the strand

	Float32		m_clumpNoise;				//!< [0 - 1.0] probability of each hair gets clumped (0 = all hairs get clumped, 1 = clump scale is randomly distributed from 0 to 1)
	Float32		m_clumpRoundness;			//!< [0 - 2.0] exponential factor to control roundness of clump shape (0 = linear cone, clump scale *= power(t, roundness), where t is normalized distance from the root)
	Float32		m_clumpScale;				//!< [0 - 1.0] how clumped each hair face is

	Float32		m_density;					//!< [0 -    ] hair density per face (1.0 = 64 hairs per face)
	Bool		m_usePixelDensity;			//!< [true/false] whether to use per-pixel sampling or per-vertex sampling for density map

	Float32		m_lengthNoise;				//!< [0 - 1.0] length variation noise
	Float32		m_lengthScale;				//!< [0 - 1.0] length control for growing hair effect

	Float32		m_waveScale;				//!< [In Centimeters] size of waves for hair waviness 
	Float32		m_waveScaleNoise;			//!< [0 - 1.0] noise factor for the wave scale
	Float32		m_waveScaleClump;			//!< [0 - 1.0] waviness at clump level
	Float32		m_waveScaleStrand;			//!< [0 - 1.0] waviness at strand level
	Float32		m_waveFreq;					//!< [0 -    ] wave frequency (1.0 = one sine wave along hair length)
	Float32		m_waveFreqNoise;			//!< [0 - 1.0] noise factor for the wave frequency 
	Float32		m_waveRootStraighten;		//!< [0 - 1.0] For some distance from the root, we attenuate waviness so that root itself does not move [0-1]

	/// shading controls
	Float32		m_rootAlphaFalloff;			//!< [0 - 1.0] falloff factor for alpha transition from root 
	Vec4		m_rootColor;				//!< [0 - 1.0] color of hair root (when hair textures are not used)
	Vec4		m_tipColor;				//!< [0 - 1.0] color of hair tip (when hair textures are not used)
	Float32		m_rootTipColorWeight;		//!< [0 - 1.0] blend factor between root and tip color in addition to hair length
	Float32		m_rootTipColorFalloff;		//!< [0 - 1.0] falloff factor for root/tip color interpolation

	Float32		m_diffuseBlend;				//!< [0 - 1.0] blend factor between Kajiya hair lighting vs normal skin lighting.
	Float32		m_hairNormalWeight;			//!< [0 - 1.0] blend factor between mesh normal vs hair normal. Use higher value for longer (surface like) hair.
	Int32		m_hairNormalBoneIndex;		//!< [-1 - number of bones] index for the bone which we use as model center for diffuse shading purpose. If < 0 uses the model shading center.

	Vec4		m_specularColor;			//!< [0 - 1.0] specular color
	Float32		m_specularNoiseScale;		//!< [0 - 1.0] amount of specular noise
	Float32		m_specularEnvScale;			//!< [0 - 1.0] amount of specular scale from env probe
	Float32		m_specularPrimary;			//!< [0 - 1.0] primary specular factor
	Float32		m_specularPowerPrimary;		//!< [0 - ] primary specular power exponent
	Float32		m_specularPrimaryBreakup;	//!< [0 - 1.0] shift factor to make specular highlight move with noise
	Float32		m_specularSecondary;		//!< [0 - 1.0] secondary specular factor
	Float32		m_specularSecondaryOffset;	//!< [0 - 1.0] secondary highlight shift offset along tangents
	Float32		m_specularPowerSecondary;	//!< [0 - ] secondary specular power exponent		

	Float32		m_glintStrength;			//!< [0 - 1.0] strength of the glint noise
	Float32		m_glintCount;				//!< [0 - 1024] number of glint sparklers along each hair
	Float32		m_glintExponent;			//!< [0 - ] glint power exponent

	Bool		m_castShadows;				//!< [true/false] this hair cast shadows onto the scene
	Bool		m_receiveShadows;			//!< [true/false] this hair receives shadows from the scene
	Float32		m_shadowSigma;				//!< [In Centimeters] distance through hair volume beyond which hairs get completely shadowed.

	UInt32		m_strandBlendMode;			//!< [EStrandBlendMode] blend mode when strand texture is used. Supported mode are defined in EStrandBlendMode
	Float32		m_strandBlendScale;			//!< [0 - 1.0] scale strand texture before blend

	// simulation control
	Float32		m_backStopRadius;			//!< [0 - 1.0] radius of backstop collision (normalized along hair length)
	Float32		m_bendStiffness;			//!< [0 - 1.0] stiffness for bending, useful for long hair
	Float32		m_damping;					//!< [0 - ] damping to slow down hair motion
	Vec3		m_gravityDir;				//!< [0 - 1.0] gravity force direction (unit vector) (in worldspace)
	Float32		m_friction;					//!< [0 - 1.0] friction when capsule collision is used
	Float32		m_massScale;				//!< [In Meters] mass scale for this hair
	Float32		m_inertiaScale;				//!< [0 - 1.0] inertia control. (0: no inertia, 1: full inertia)
	Float32		m_inertiaLimit;				//!< [In Meters] speed limit where everything gets locked (for teleport etc.)
	Float32		m_interactionStiffness;		//!< [0 - 1.0] how strong the hair interaction force is
	Float32		m_rootStiffness;			//!< [0 - 1.0] attenuation of stiffness away from the root (stiffer at root, weaker toward tip)
	Float32		m_pinStiffness;				//!< [0 - 1.0] stiffness for pin constraints
	Bool		m_simulate;					//!< [true/false] whether to turn on/off simulation
	Float32		m_stiffness;				//!< [0 - 1.0] how close hairs try to stay within skinned position
	Float32		m_stiffnessStrength;		//!< [0 - 1.0] how strongly hairs move toward the stiffness target
	Float32		m_stiffnessDamping;			//!< [0 - 1.0] how fast hair stiffness generated motion decays over time
	Float32		m_tipStiffness;				//!< [0 - 1.0] attenuation of stiffness away from the tip (stiffer at tip, weaker toward root)
	Bool		m_useCollision;				//!< [true/false] whether to use the sphere/capsule collision or not for hair/body collision
	Vec3		m_wind;						//!< [In Meters] vector force for main wind direction (in worldspace)
	Float32		m_windNoise;				//!< [0 - 1.0] strength of wind noise

	Vec4		m_stiffnessCurve;			//! [0 - 1.0] curve values for stiffness 
	Vec4		m_stiffnessStrengthCurve;	//! [0 - 1.0] curve values for stiffness strength
	Vec4		m_stiffnessDampingCurve;	//! [0 - 1.0] curve values for stiffness damping
	Vec4		m_bendStiffnessCurve;		//! [0 - 1.0] curve values for bend stiffness
	Vec4		m_interactionStiffnessCurve;//! [0 - 1.0] curve values for interaction stiffness
	Bool		m_useDynamicPin;			//! [true/false] whether to turn on/off dynamic pin

	// lod controls
	Bool		m_enableLod;				//!< [true/false] whether to enable/disable entire lod scheme

	Bool		m_enableDistanceLod;		//!< [true/false] whether to enable lod for far away object (distance LOD)
	Float32		m_distanceLodStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start fading out (by reducing density)
	Float32		m_distanceLodEnd;			//!< [In Meters] distance (in scene unit) to camera where fur will completely disappear (and stop simulating)
	Float32		m_distanceLodFadeStart;		//!< [In Meters] distance (in scene unit) to camera where fur will fade with alpha from 1 (this distance) to 0 (DistanceLODEnd)
	Float32		m_distanceLodDensity;		//!< [0 - ] density when distance LOD is in action.  hairDensity gets scaled based on LOD factor.
	Float32		m_distanceLodWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	Bool		m_enableDetailLod;			//!< [true/false] whether to enable lod for close object (detail LOD)
	Float32		m_detailLodStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start getting denser toward closeup density
	Float32		m_detailLodEnd;				//!< [In Meters] distance (in scene unit) to camera where fur will get full closeup density value
	Float32		m_detailLodDensity;			//!< [0 - ] density scale when closeup LOD is in action.  hairDensity gets scaled based on LOD factor.
	Float32		m_detailLodWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	Float32		m_shadowDensityScale;		//!< [0 - 1] density scale factor to reduce hair density for shadow map rendering

	Bool		m_useViewfrustrumCulling;	//!< [true/false] when this is on, density for hairs outside view are set to 0. Use this option when fur is in a closeup.
	Bool		m_useBackfaceCulling;		//!< [true/false] when this is on, density for hairs growing from backfacing faces will be set to 0
	Float32		m_backfaceCullingThreshold; //!< [-1 - 1.0] threshold to determine backface, note that this value should be slightly smaller 0 to avoid hairs at the silhouette from disappearing

	Bool		m_useCullSphere;			//!< [true/false] when this is on, hairs get culled when their root points are inside the sphere
	Mat4x4		m_cullSphereInvTransform;	//!< inverse of general affine transform (scale, rotation, translation..) applied to a unit sphere centered at origin

	UInt32		m_splineMultiplier;			//!< how many vertices are generated per each control hair segments in spline curves

	// asset grouping
	UInt32		m_assetType;				//!< This value can be used to classify different types of hair in a game. (e.g. 0 = fur, 1 = hair, 2 = very long hair, etc.)
	UInt32		m_assetPriority;			//!< This value can be used to sort assets via importance in a game.
	UInt32		m_assetGroup;				//!< This can be used to cluster a set of assets to character grouping.

	// drawing option
	Bool		m_drawRenderHairs;			//!< [true/false] draw render hair
	Bool		m_visualizeBones;			//!< [true/false] visualize skinning bones
	Bool		m_visualizeBoundingBox;		//!< [true/false] draw bounding box of hairs
	Bool		m_visualizeCapsules;		//!< [true/false] visualize collision capsules
	Bool		m_visualizeControlVertices; //!< [true/false] draw control vertices of guide hairs
	Bool		m_visualizeCullSphere;		//!< [true/false] draw cull sphere
	Bool		m_visualizeFrames;			//!< [true/false] visualize coordinate frames
	Bool		m_visualizeGrowthMesh;		//!< [true/false] draw growth mesh
	Bool		m_visualizeGuideHairs;		//!< [true/false] draw guide hairs
	Bool		m_visualizeHairInteractions;//!< [true/false] draw hair interaction lines
	UInt32		m_visualizeHairSkips;		//!< [0 - ] for per hair visualization, how many hairs to skip?
	Bool		m_visualizeLocalPos;		//!< [true/false] visualize target pose for bending
	Bool		m_visualizePinConstraints;	//!< [true/false] whether to visualize pin constraint spheres
	Bool		m_visualizeShadingNormals;	//!< [true/false] visualize normals used for hair shading
	Bool		m_visualizeShadingNormalBone; //!< [true/false] visualize bone used as shading normal center
	Bool		m_visualizeSkinnedGuideHairs; //!< [true/false] draw skinned positions for guide hairs

	UInt32		m_colorizeMode;				//!< [ColorizeMode] colorize hair based on various terms. See ColorizeMode.
	
	ETextureChannel m_textureChannels[TextureType::COUNT_OF]; //!< texture channel for each control textures.  
	
	Mat4x4		m_modelToWorld;			//!< render time transformation to offset hair from its simulated position

	// default values
	InstanceDescriptor() :
		m_enable(true),

		// default geometry parameters
		m_width(1.0f),
		m_widthNoise(0.0f),
		m_widthRootScale(1.0f),
		m_widthTipScale(0.1f),

		m_clumpNoise(0.0f),
		m_clumpRoundness(1.0f),
		m_clumpScale(0.0f),
		
		m_density(1.0f), 
		m_lengthNoise(1.0f),
		m_lengthScale(1.0f),
			
		m_usePixelDensity(false),
		m_waveScale(0.0f),
		m_waveScaleClump(0.0f),
		m_waveScaleStrand(1.0f),
		m_waveScaleNoise(0.5f),
		m_waveFreq(3.0f),
		m_waveFreqNoise(0.5f),
		m_waveRootStraighten(0.0f),

		// default shading parameters
		m_diffuseBlend(0.5f),
		m_hairNormalWeight(0.0f),
		m_hairNormalBoneIndex(-1),

		m_glintStrength(0.0f),
		m_glintCount(256.0f),
		m_glintExponent(2.0f),
		m_rootTipColorWeight(0.5f),
		m_rootTipColorFalloff(1.0f),

		m_specularNoiseScale(0.0f),
		m_specularEnvScale(0.25f),
		m_specularPrimary(0.1f),
		m_specularPrimaryBreakup(0.0f),
		m_specularSecondary(0.05f),
		m_specularSecondaryOffset(0.1f),
		m_specularPowerPrimary(100.0f),
		m_specularPowerSecondary(20.0f),

		m_rootAlphaFalloff(0.0f),

		m_shadowSigma(0.2f),
		m_castShadows(true),
		m_receiveShadows(true),

		m_strandBlendMode(UInt32(StrandBlendMode::OVERWRITE)),
		m_strandBlendScale(1.0f),

		// default simulation parameters
		m_simulate(true),
		m_backStopRadius(0.0f),
		m_bendStiffness(0.0f),
		m_damping(0.0f),
		m_friction(0.0f),
		m_inertiaScale(1.0f),
		m_inertiaLimit(1000.0f),
		m_interactionStiffness(0.0f),
		m_massScale(10.0f),
		m_windNoise(0.0f),
		m_stiffness(0.5f),
		m_stiffnessStrength(1.0f),
		m_stiffnessDamping(0.0f),
		m_rootStiffness(0.5f),
		m_pinStiffness(1.0f),
		m_tipStiffness(0.0f),
		m_useCollision(false),
		m_useDynamicPin(false),

		// default LOD parameters
		m_enableLod(false),

		m_enableDistanceLod(true),
		m_distanceLodStart(5.0f), 
		m_distanceLodEnd(10.0f), 
		m_distanceLodFadeStart(1000.0f),
		m_distanceLodDensity(0.0f),
		m_distanceLodWidth(1.0f),

		m_enableDetailLod(true),
		m_detailLodStart(2.0f), 
		m_detailLodEnd(1.0f), 
		m_detailLodDensity(1.0f),
		m_detailLodWidth(1.0f),

		m_shadowDensityScale(0.5f),

		m_useViewfrustrumCulling(true),
		m_useBackfaceCulling(false),
		m_backfaceCullingThreshold(-0.2f),
		m_useCullSphere(false),

		m_splineMultiplier(4),

		m_assetType(0),
		m_assetPriority(0),
		m_assetGroup(0),

		// visualization options
		m_drawRenderHairs(true),		
		m_visualizeBones(false),
		m_visualizePinConstraints(false),
		m_visualizeCapsules(false),
		m_visualizeGrowthMesh(false),	
		m_visualizeGuideHairs(false),	
		m_visualizeControlVertices(false),
		m_visualizeBoundingBox(false),
		m_visualizeCullSphere(false),
		m_visualizeShadingNormalBone(false),
		m_visualizeHairInteractions(false),
		m_visualizeSkinnedGuideHairs(false),	
		m_visualizeFrames(false),
		m_visualizeLocalPos(false),
		m_visualizeShadingNormals(false),
		m_visualizeHairSkips(0),

		m_colorizeMode(UInt32(ColorizeMode::NONE))

		{
			m_gravityDir.x = 0.0f; 
			m_gravityDir.y = 0.0f; 
			m_gravityDir.z = -1.0f;

			m_wind.x = 0.0f; 
			m_wind.y = 0.0f; 
			m_wind.z = 0.0f;

			m_rootColor.x = 1.0f; m_rootColor.y = 1.0f; m_rootColor.z = 1.0f; m_rootColor.w = 1.0f;
			m_tipColor.x = 1.0f; m_tipColor.y = 1.0f; m_tipColor.z = 1.0f; m_tipColor.w = 1.0f;
			m_specularColor.x = 1.0f; m_specularColor.y = 1.0f; m_specularColor.z = 1.0f; m_specularColor.w = 1.0f;

			NvCo::setIdentity(m_modelToWorld);
			NvCo::setIdentity(m_cullSphereInvTransform);


#define NV_HAIR_MAKE_IDENTITY(M) M._11 = 1.0f; M._12 = 0.0f; M._13 = 0.0f; M._14 = 0.0f; \
			M._21 = 0.0f; M._22 = 1.0f; M._23 = 0.0f; M._24 = 0.0f; \
			M._31 = 0.0f; M._32 = 0.0f; M._33 = 1.0f; M._34 = 0.0f; \
			M._41 = 0.0f; M._42 = 0.0f; M._43 = 0.0f; M._44 = 1.0f;

			NV_HAIR_MAKE_IDENTITY(m_modelToWorld);

			NV_HAIR_MAKE_IDENTITY(m_cullSphereInvTransform);

#undef NV_HAIR_MAKE_IDENTITY

#define NV_HAIR_SETX(X, V) X.x = V; X.y = V; X.z = V; X.w = V;

			NV_HAIR_SETX(m_stiffnessCurve, 1.0f);
			NV_HAIR_SETX(m_stiffnessStrengthCurve, 1.0f);
			NV_HAIR_SETX(m_stiffnessDampingCurve, 1.0f);
			NV_HAIR_SETX(m_bendStiffnessCurve, 1.0f);
			NV_HAIR_SETX(m_interactionStiffnessCurve, 1.0f);
#undef NV_HAIR_SETX

			for (IndexT i = 0; i < IndexT(TextureType::COUNT_OF); i++)
				m_textureChannels[i] = TextureChannel::RED;
		}
};

/*! \brief statistics for optimization and profiling
	\details For statistics or profiling purpose, one can query the Sdk how much resources are currently consumed.
	\see Use Sdk.computeStats() to retrieve this data. */
struct Stats
{
	NV_CO_DECLARE_CLASS_BASE(Stats);

	Int	m_numHairs;					//!< total hair counts for the hair instances
	Int	m_numFaces;					//!< total face counts for the hair instance
	Float m_averageNumCvsPerHair;	//!< average number of control vertices (CVs) per hair
	Float m_averageDensity;			//!< average density, accounting for density maps, etc.
	Float m_averageHairsPerFace;	//!< average hairs per face

	Float m_distanceLodFactor;		//!< distance LOD factor
	Float m_detailLodFactor;		//!< closeup LOD factor
	Float m_camDistance;			//!< distance to camera

	Stats() :
		m_numHairs(0),
		m_numFaces(0),
		m_averageNumCvsPerHair(0.0f),
		m_averageDensity(0.0f),
		m_averageHairsPerFace(0.0f),
		m_distanceLodFactor(0.0f),
		m_detailLodFactor(0.0f),
		m_camDistance(0.0f)
	{}
};

/** \brief Data structure used to customize HairWorks shader settings.
	\details Users can customize HairWorks runtime by providing their render settings with this structure.
	\see Sdk.renderHairs() */
struct ShaderSettings
{
	NV_CO_DECLARE_CLASS_BASE(ShaderSettings);

	Bool	m_useCustomConstantBuffer;	//!< If true, HairWorks will not bind constant buffer
	Bool	m_shadowPass;				//!< If true, density and width will be adjusted based on m_shadowDensityScale of InstanceDescriptor
	Int32	m_shaderIndex;				//!< Shader index to use. (Only used on some rendering APIs, if not used set to 0)

	NV_FORCE_INLINE ShaderSettings(Bool	useCustomConstantBuffer	= false, Bool shadowPass = false, Int32 shaderIndex = 0):
		m_useCustomConstantBuffer(useCustomConstantBuffer),
		m_shadowPass(shadowPass),
		m_shaderIndex(shaderIndex)
	{
	}
};

/*! \brief DepthOp
\details Enumeration of depth test/actions supported. */
class DepthOp 
{
	DepthOp(); public: enum Enum
	{
		UNKNOWN,			///< Undefined -> typically invalid
		ALWAYS,				///< Always write
		WRITE_LESS,			///< Writes when test is less
		WRITE_GREATER,			///< Writes when test if greater
		TEST_LESS,				///< Displays pixel if less, no write
		TEST_GREATER,			///< Displays pixel if greater, no write
		COUNT_OF,
	};
};
typedef DepthOp::Enum EDepthOp;

/** \brief Structure used to customize how hair visualization is rendered. 
\details Specifies rendering features for how a hair visualization is rendered.
\see Sdk.renderVisualization() */
struct VisualizationSettings
{
	NV_FORCE_INLINE VisualizationSettings():m_depthOp(DepthOp::WRITE_LESS) {}
	EDepthOp m_depthOp;			//< The depth op to use (may or may not be honored depending on underlying rendering API 
};

/*! \brief shader cache settings to create optimized shader per each hair asset.
	\details By giving hints about which features are used, HairWorks can build optimized shader before runtime.
			 Note that once an option is disabled in shader cache, the feature will not work even if it is enabled in instance descriptor in runtime.
	\see Sdk.addToShaderCache() to add optimized shader. */
struct ShaderCacheSettings
{
	NV_CO_DECLARE_CLASS_BASE(ShaderCacheSettings);

	enum Flag
	{
		FLAG_CULL_SPHERE	= 0x01,	//!< if cull sphere is used (InstanceDescriptor.m_useCullSphere == true)
		FLAG_CLUMPING		= 0x02,	//!< if clumping is used (InstanceDescriptor.m_clumpScale > 0)
		FLAG_WAVE_STRAND	= 0x04,	//!< if strand waviness is used (InstanceDescriptor.m_waveScale > 0 && InstanceDescriptor.m_waveStrand > 0)
		FLAG_WAVE_CLUMP		= 0x08,	//!< if strand waviness is used (InstanceDescriptor.m_waveScale > 0 && InstanceDescriptor.m_waveClump > 0)
		FLAG_PIXEL_DENSITY	= 0x10,	//!< if per-pixel density option is used (InstanceDescriptor.m_usePixelDensity = true)
		FLAG_SINGLE_TARGET	= 0x20,	//!< if rendering to a single target (ie non cubemap rendering)
		FLAG_MAX_BIT		= 0x40,
	};

	Int32 m_useFlags;				///< Combination of Flag flags 
	Int32 m_textureUsedFlags;		///< Bit set for each of NvHair::TextureType::COUNT_OF
	UInt32 m_channelPerTexture;		///< Each channel is held in 2 bits per NvHair::TextureType::COUNT_OF
	
		/// True if used
	NV_FORCE_INLINE Bool isUsed(Flag flag) const { return (m_useFlags & flag) != 0; }
		/// Set as used
	NV_FORCE_INLINE void setUsed(Flag flag, Bool v) { m_useFlags = v ? (m_useFlags | flag) : (m_useFlags & ~flag); }

	NV_FORCE_INLINE Bool isTextureUsed(Int i) const { NV_CORE_ASSERT(i >= 0 && i < Int(TextureType::COUNT_OF)); return (m_textureUsedFlags & (1 << i)) != 0; }
		/// Set the texture is used
	NV_FORCE_INLINE void setTextureUsed(Int i, Bool v) { NV_CORE_ASSERT(i >= 0 && i < Int(TextureType::COUNT_OF));  m_textureUsedFlags = v ? (m_textureUsedFlags | (1 << i)) : (m_textureUsedFlags & (~(1 << i))); }

		/// Set the channel
	NV_FORCE_INLINE void setChannel(Int i, ETextureChannel chan)
	{
		const Int shift = i + i;
		m_channelPerTexture &= ~(UInt32(0x3) << shift);
		m_channelPerTexture |= (UInt32(chan) << shift);
	}
		/// Get the channel
	NV_FORCE_INLINE ETextureChannel getChannel(Int i) const { return ETextureChannel((m_channelPerTexture >> (i + i)) & 3); }
		/// Set everything to 0
	void zero() { m_useFlags = 0; m_textureUsedFlags = 0; m_channelPerTexture = 0; }

		/// Apply the rhs as a mask.
	Void applyMask(const ThisType& rhs)
	{
		m_channelPerTexture &= rhs.m_channelPerTexture;
		m_textureUsedFlags &= rhs.m_textureUsedFlags;
		m_useFlags &= rhs.m_useFlags;
	}
		// ==
	Bool operator==(const ThisType& rhs) const
	{
		return m_useFlags == rhs.m_useFlags &&
			m_textureUsedFlags == rhs.m_textureUsedFlags &&
			m_channelPerTexture == rhs.m_channelPerTexture;
	}
		// !=
	NV_FORCE_INLINE Bool operator!=(const ThisType& rhs) const { return !(*this == rhs); }

		/// Ctor. Default option is to turn on all the options
	ShaderCacheSettings()
	{
		m_useFlags = FLAG_MAX_BIT - 1;
		m_textureUsedFlags = (1 << Int(TextureType::COUNT_OF)) - 1;		// Set all textures on
		m_channelPerTexture = 0;										// Set all to 0 (RED)
	}

	// set feature sets from instance descriptor.
	// Note that texture references are not part of instance descriptor, so still need to be set after this function.
	Void setFromInstanceDescriptor(const InstanceDescriptor& desc)
	{
		setUsed(FLAG_PIXEL_DENSITY, desc.m_usePixelDensity);
		setUsed(FLAG_CULL_SPHERE, desc.m_useCullSphere);

		setUsed(FLAG_CLUMPING, desc.m_clumpScale > 0.0f);
		setUsed(FLAG_WAVE_STRAND, (desc.m_waveScale > 0.0f) && (desc.m_waveScaleStrand > 0.0f));
		setUsed(FLAG_WAVE_CLUMP, (desc.m_waveScale > 0.0f) && (desc.m_waveScaleClump > 0.0f));

		for (Int i = 0; i < Int(TextureType::COUNT_OF); i++)
			setChannel(i, desc.m_textureChannels[i]); //!< texture channel for each control textures.  
	}
};

/*!\brief Constant buffer structure to map hair shading data to DX constant buffer
	\see Use Sdk.prepareShaderConstantBuffer() to get this data structure properly mapped for shader use. */
struct ShaderConstantBuffer
{
	enum 
	{
		BUFFER_SIZE = 512 // = 256 + 256 constant buffer size used by HairWorks pixel shader.
	};
	Float32 m_data[BUFFER_SIZE]; 
};

/*!\brief Settings to apply coordinate/unit conversion for hair asset loading.
	\details When hair asset is exported from various DCC tools, needs may arise to properly convert unit and coordinate system settings to match
		different setups in game engines. Use the following data structure to provide information about how HairWorks should convert those.
	\note The axis conversion uses data stored in AssetDescriptor (m_upAxis, m_handedness).
		If any of the data is set to unknown (0), or if any of target hint is unknown, we do not perform any default conversion.
	\note If m_conversionMatrix is set to non-null, this overrides standard conversion and we multiply this matrix as follows
		For all position data (hair vertices, etc.)
			p_converted = p_old * m_conversionMatrix
		For all matrix data (bind pose matrix, etc.)
			M_converted = M_old * m_conversionMatrix. */
struct ConversionSettings
{
	NV_CO_DECLARE_CLASS_BASE(ConversionSettings);

	EAxisHint m_targetUpAxisHint;				//!< up axis used by the game engine that will use this asset in runtime
	EHandednessHint m_targetHandednessHint;	//!< handedness of original tools that generated this asset
	Mat4x4*	m_conversionMatrix;				//!< If not NV_NULL, we use this conversion matrix instead
	Float32	m_targetSceneUnit;						//!< scene unit (in centimeters) for game engine.  0 means unknown (use source unit)
													// Centimeter (default): 1.0, Meter: 100.0, Inch: 2.54, Decimeter: 10.0
	ConversionSettings() :
		m_targetUpAxisHint(AxisHint::UNKNOWN),
		m_targetHandednessHint(HandednessHint::UNKNOWN),
		m_conversionMatrix(NV_NULL),
		m_targetSceneUnit(0.0f)
	{
	}
};

/*!\brief Structure for describing viewport configuration. 
*/
struct Viewport
{
	Void init(Float topLeftX, Float topLeftY, Float width, Float height, Float minDepth = 0.0f, Float maxDepth = 1.0f)
	{
		m_topLeftX = topLeftX;
		m_topLeftY = topLeftY;
		m_width = width;
		m_height = height;
		m_minDepth = minDepth;
		m_maxDepth = maxDepth;
	}

	Float m_topLeftX;
	Float m_topLeftY;
	Float m_width;
	Float m_height;
	Float m_minDepth;
	Float m_maxDepth;
};


struct _AsyncHandle;
/*! AsyncHandle is used for calls which can return results asynchronously - meaning a method
that may only be able to return a result at some point in the future, and can not or does not block 
the thread waiting for the result. 

The basic idea behind the async handle is to provide a 'cookie' to track a result, such that if the 
method call cannot give you the result now, you can you the cookie in the method to ask for the 
result in the future. 

To start with the simplest scenario - where the implementation can only block, or can return a result
immediately. If you know the implementation implements blocking calls and thats suitable for your purposes
then you can just pass NV_NULL to the async handle pointer. If it is possible to block or return the result
immediately the call will do that, if not it will return NV_FAIL.

To do a call that may work asynchronously you must pass in a pointer to a AsyncHandle. This should be initialized
to NV_NULL initially, to indicate this is the initial call to set up the request. The method call can return

\code
NV_OK				// The results were returned and can be used
NV_E_MISC_PENDING	// The AsyncHandle has had a cookie written to it. Use in the future to get the result
\endcode

If it failed for another reason, this will be returned as an error.

With the AsyncHandle 'cookie' set, you can request that specific result again in the future. NOTE! When in 
this state, all the other input parameters are effectively ignored - the AsyncHandle encapsulates the 
parameterization and the state when the method was called. That said it is a good convention to aim to pass in
the same parameters to maintain consistency.  

With the AsyncHandle not being NV_NULL a method can return the following results

\code
NV_OK						// The results were available and have been set. NOTE! Will also set AsyncHandle to NV_NULL because the request has completed.
NV_E_MISC_PENDING			// The results were not available, will need to be requested again at some future point
NV_E_MISC_INVALID_HANDLE	// AsyncHandles can be destroyed before a request completes (say the instance is destroyed), or the requestCancelled. NOTE! If this is returned the AsyncHandle will be set to NV_NULL.
\endcode

NOTE! 

1. If NV_OK or NV_E_MISC_INVALID_HANDLE is returned the call WILL set the AsyncHandle to NV_NULL - because it has either expired returned the result, or it was invalid.
2. AsyncHandles are 'safe' in that if a request is made invalid, the object the request is being made on destroyed, the request canceled the API will detect the situation, clear the AsyncHandle and return NV_E_MISC_INVALID_HANDLE.
3. It is typically an incorrect usage to store an async handle in a local variable, unless it is later copied somewhere where it can be used later.
4. Typically you can't use a tight loop asking for a result to make an async method appear immediately. At a minimum calls to onGpuWorkSubmitted may be needed, or perhaps some other OS/API specific behavior.  
5. Writing code that supports async will typically work transparently on a blocking/immediate returning API - as all that will happen is AsyncHandle is never set, and the result is returned. 

Finally generally methods that take a AsyncHandle typically have a Bool parameter asyncLatest. This is only relevant if the call is on an async implementation. If false then the behavior is as
previously described. If true the call will either kick off a whole new async request, or return the latest result. Either way the method will return NV_OK
as it will have returned a new result. Implementing without the asyncLatest is a little convoluted and would look something like the following...

\code{.cpp}
    AsyncHandle prevHandle = m_asyncHandle;
	Result res = hairSdk->computeStats(&m_asyncHandle, false, m_instanceId, m_stats);
	if (res == NV_E_MISC_INVALID_HANDLE)
	{	
		// If the handle is now invalid, initiate a new request, and res is the result
		res = computeStats(&m_asyncHandle, false, m_instanceId, m_stats);
	}
	else if (NV_SUCCEEDED(res) && prevHandle)
	{
		// We've just received an async result, initiate a new request (but ignore the result, as NV_OK means we have a new result which we do)
		computeStats(&m_asyncHandle, false, m_instanceId, m_stats);
	}
\endcode

In essence if an async call completes, it initiates another call (most likely an async call). Thus when using an async implementation this makes it simpler to 'poll' for the latest results
by just repeatedly calling the method with asyncRepeat set to true. On a blocking/non async implementation asyncRepeat has no effect. Thus if the usage of the API is to poll, and the 
most recent results desired use asyncRepeat set to true. If more controlled access async results are required - such as the values of each result individually  

Thus a simple way of using an async handle might be as follows

\code{.cpp}
struct AnInstance
{
	AnInstance():m_statsAsyncHandle(NV_NULL), m_instanceId(NvHair::INSTANCE_ID_NULL) { }
	Void update();

	NvHair::AsyncHandle m_statsAsyncHandle;				///< Probably belongs to object  
	NvHair::InstanceId m_instancId;
	NvHair::Stats m_stats;
};

Void AnInstance::update()	
{
	// NOTE! Passing true to asyncRepeat to make sure there is always an async request in flight.
	hairSdk->computeStats(&m_statsAsyncHandle, true, m_instanceId, m_stats);	
}
\endcode
 */
typedef _AsyncHandle* AsyncHandle;

/*! \brief This abstract class provides all the API for HairWorks runtime */
class Sdk
{
public:

	/*=============================================================================================
		OVERVIEW

		To use HairWorks runtime, we first need to load the HairWorks dll and create this Sdk object.
		See loadHairSdk(const Char* dllPath, UInt32 version = NV_HAIR_VERSION) defined in NvHairWinLoadSdk.h.
		Once SDK's DLL is loaded, we can use the Sdk object to access all the APIs below.
		When Sdk is not needed (typically at the shutdown stage of a game), call release().
	=============================================================================================*/

		///  brief Deletes this SDK object. 
	virtual void release() = 0;

	/*=============================================================================================
		HAIR ASSET PREPARATION AND MANAGEMENT

		The first step is to get hair asset created and loaded, and get hair asset ID.
		The hair assets can be either created manually or loaded from a file (.apx/.apb).
		
		See functions below.
	=============================================================================================*/

	/*! \brief loads hair asset data from descriptor. 
		\param [in] assetDesc The hair asset descriptor created from apx file, etc.
		\param [out] assetIdOut Upon success, assetID is filled by a valid AssetId value.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result createAsset(const AssetDescriptor& assetDesc, AssetId& assetIdOut) = 0;

	/*! \brief destroy/release hair asset data
		\param [in] assetId hair asset ID to delete */
	virtual void freeAsset(const AssetId assetId ) = 0;

		/*! \brief returns the serialized format implied by the extension.
		  \param [in] ext The filename extension.
		  \return The associate file format or SerializeFormat::UNKNOWN if not known */ 
	virtual ESerializeFormat getSerializeFormatFromExtension(const char* ext) = 0;
		
	/*! \brief load hair asset data from a memory buffer that contains (.apx/.apb) file content
		\param [in] stream ReadStream that will be read from.
		\param [out] assetIdOut Upon success, assetID is filled by a valid AssetId value.
		\param [out] infoOut If the info is not NV_NULL, the info is filled upon success.
		\param [in] settings Conversion settings regarding scene unit, up vector, coordinate handedness, etc. See ConversionSettings.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result loadAsset(NvCo::ReadStream* stream, AssetId& assetIdOut, AssetHeaderInfo* infoOut = NV_NULL, const ConversionSettings* settings = NV_NULL) = 0;
	
	/*! \brief save hair asset data to an (.apx/.apb) file
		\param [in] stream WriteStream that the asset will be serialized out to 
		\param [in] format The ESerializeFormat that defines what format the data will be written in.
		\param [in] assetId hair asset ID to store.
		\param [in] descriptor Instance descriptor to save in file.  If this is NV_NULL, default instance descriptor for the asset will be saved.
		\param [in] info file header info to be stored. info can be NV_NULL.
		\param [in] textureNames Set texture file names if different from the names in the original asset. If NV_NULL, texture file names loaded from original asset will be saved.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result saveAsset(NvCo::WriteStream* stream, ESerializeFormat format, AssetId assetId, const InstanceDescriptor* descriptor = NV_NULL, const AssetHeaderInfo* info = NV_NULL, const Char*const* textureNames = NV_NULL) = 0;
	
	/*! \brief save hair instance data to an (.apx/.apb) file
		\param [in] stream WriteStream that the instance will be serialized out to
		\param [in] format The ESerializeFormat that defines what format the data will be written in.
		\param [in] instanceId hair instance ID to save.
		\param [in] info file header info to be stored. info can be NV_NULL.
		\param [in] textureNames Set texture file names if different from the names in the original asset. If NV_NULL, texture file names loaded from original asset will be saved.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result saveInstance(NvCo::WriteStream* stream, ESerializeFormat format, InstanceId instanceId, const AssetHeaderInfo* info = NV_NULL, const Char*const* textureNames = NV_NULL) = 0;

	/*! \brief copy some parts of assets from one asset to another
		\param[in] fromAssetId asset id to copy property from
		\param[in] toAssetId asset id to copy property to
		\param[in] settings controls how the copy is performed
		\note Useful for importing certain part of asset data.  fromAssetID and toAssetID cannot be the same.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result copyAsset(AssetId fromAssetId, AssetId toAssetId, const AssetCopySettings& settings = AssetCopySettings()) = 0;

	/*! \brief Get hair default instance descriptor from the asset.
		\param [in] assetId hair asset id that holds the default instance descriptor
		\param [out] descriptorOut Hair instance descriptor to copy the data to.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getInstanceDescriptorFromAsset(AssetId assetId, InstanceDescriptor& descriptorOut) = 0;

	/*! \brief resample number of cvs to target number
		\param[in] assetId asset identifier to resample
		\param[in] numTargetPointsPerHair number of cvs for each hair
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result resampleGuideHairs(AssetId assetId, Int numTargetPointsPerHair) = 0;

	/*=============================================================================================
		HAIR SHADER CACHE MANAGEMENT

		HairWorks provides options to create optimized shader for each specific asset.
		By removing unused features, performance can be significantly improved. 
		This 'cooking' process can be performed before game runs and does not require D3D device or context.
		This process can be done as pre-process once all the assets are locked for game release.

		Use the following functions to create, store, and load optimized shader caches.
		NOTE: If shader cache is not defined, HairWorks will run in unoptimized mode.
	=============================================================================================*/

	/*! \brief clear entire shader cache database
		\details call this function in the beginning of shader cache cooking process.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result clearShaderCache() = 0;

	/*! \brief add new shader cache based on specified shader settings
		\details add shader to the cache with specified settings
		\param[in] settings flags that affect shader cache generation.  If matching shader already exists, this will be skipped.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result addToShaderCache(const ShaderCacheSettings& settings) = 0;

	/*! \brief Save serialized shader cache.
		\details Once caches has been added, use this function to get serialized cache buffer. Users can write this data to their own file format for future use. 
		NOTE! That the file format is platform, HW API, and graphics Api dependant. Trying to load a shader cache that doesn't match has undefined behavior
		\param[in] stream WriteStream that the shader cache is filled with. 
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result saveShaderCache(NvCo::WriteStream* stream) = 0;

	/*=============================================================================================
		RENDERER INITIALIZATION

		Once the game starts running and DX device is prepared, we should call initRenderResources() once for Sdk to 
		consequently manage internal DX resources.
	=============================================================================================*/

	/*! \brief Initialize internal render state variables and shaders.  
		\param [in] device The DX11 device that HairWorks should use to create all the DX11 resources
		\param [in] context When d3d context is known at time of calling this function, set it here. If not use setCurrentContext() later.	
		\param [in] other Extra Api dependent information required to initialize HairWorks.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note To pass in the ApiDevice, and ApiContext use make s
		\note On DX11 ApiDevice and ApiContext are ID3D11Device* and ID3D11DeviceContext* respectively.
		\code{.cpp}
		To pass those parameters, make sure you include <Nv/Common/Platform/Dx11/NvCoDx11Handle.h>, and to call the method wrap them like so 
		ID3D11Device* device = ...;
		ID3D11DeviceContext* context = ...;
		hairSdk->initRenderResources(NvCo::Dx11Type::wrap(device), NvCo::Dx11Type::wrap(context));
		\endcode
		\note On Dx12 ApiDevice and ApiContext are ID3D12Device* and ID3dGraphicsCommandList* respectively. 
		To pass those parameters, make sure you 
		\code{.cpp}
		#include <Nv/HairWorks/Platform/Dx12/NvHairDx12SdkHandle.h> 
		ID3D12Device* device = ...;
		ID3D12GraphicsCommandList* commandList = ...;
		NvHair::Dx12InitInfo initInfo;
		// Initialize the members of initInfo

		hairSdk->initRenderResources(NvCo::Dx12Type::getHandle(device), NvCo::Dx12Type::getHandle(context), NvHair::Dx12SdkType::getPtr(&initInfo));
		\endcode
		This must be filled in with the render target and depth buffer target formats.
		*/
	virtual Result initRenderResources(const NvCo::ApiDevice& device, const NvCo::ApiContext& context = NvCo::ApiContext::getNull(), const NvCo::ConstApiPtr& other = NvCo::ApiPtr::getNull()) = 0;

	/*! \brief Load previously cooked shader cache.
		\details This fills internal shader cache from serialized data that was generated by saveShaderCacheToMemory() function calls.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result loadShaderCache(NvCo::ReadStream* stream) = 0;

	/*! \brief Clean up all the internally used DX11 resources.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual void freeRenderResources() = 0;

	/*! \brief set current rendering context. 
		All subsequent HairWorks calls will use this context for simulation and rendering
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result setCurrentContext(const NvCo::ApiContext& context) = 0;

	/*=============================================================================================
		HAIR INSTANCE MANAGEMENT

		Given properly initialized Sdk object and hair asset ID, we can now instantiate an actual 
		hair instance object anytime during the game play, allowing hair creatures to be dynamically 
		spawned or deleted on the fly.
		All the control parameters defined in the InstanceDescriptor can be updated anytime.
		Control textures for the parameters can be set either using D3D SRV, 
		and these can be set anytime once hair instance has been created.
	=============================================================================================*/

	/*! \brief Create a hair instance from given asset type
		\param [in] assetId hair asset type to create a hair instance from.  
					The assetId should have been generated from a successful call of NvHair::Sdk.loadAsset().
		\param [out] instanceIdOut If a hair instance was successfully created, an ID value is written to this variable.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result createInstance(AssetId assetId, InstanceId& instanceIdOut) = 0;

	/*! \brief Delete a given hair instance
		\param [in] instanceId hair instance to delete
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result freeInstance(InstanceId instanceId) = 0;

	/*! \brief Get currently used instance descriptor for the chosen hair instance 
		\param [in] instanceId hair instance id to get the instance descriptor
		\param [out] descriptorOut Hair instance descriptor to copy the data to.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getInstanceDescriptor(InstanceId instanceId, InstanceDescriptor& descriptorOut) = 0; 

	/*! \brief Update hair instance parameters
		\details One can change rendering/simulation parameters by updating hair instance descriptor.  
					This can be called at any time during runtime, but typically called before 
					either Sdk.renderHairs() or Sdk.stepSimulation() calls.
		\param [in] instanceId hair instance to update.
		\param [in] descriptor hair instance descriptor to update.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note Changing the model to world matrix, sets an instance into a state prior to 'preRender'. This if the matrix is changing 
		without preRender call (perhaps as part of simulationStep), rendering will fail. */
	virtual Result updateInstanceDescriptor( InstanceId instanceId, const InstanceDescriptor& descriptor) = 0;

	/*! \brief Set texture resource for control textures
		\param [in] instanceId hair instance to update texture
		\param [in] textureType	which control texture to update?
		\param [in] texture input texture, note texture resource should be managed by game itself. 
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note On Dx11, the handle should be created from a ID3D11ShaderResourceView*
		\note On Dx12, a ID3D12Resource* - the shader resource view is determined from GetDesc */
	virtual Result setTexture(InstanceId instanceId, ETextureType textureType, const NvCo::ApiHandle& texture) = 0;

	/*! \brief Get texture resource for control textures
		\param [in] instanceId hair instance to update texture
		\param [in] types the texture types wanted - pass NV_NULL for all texture types (numTextures must be set to HairTextureType::COUNT_OF)
		\param [in] numTextures
		\param [out] texturesOut textures for each textureType and instance (see notes).
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note The resources out array type is dependent on the underlying rendering API being used. 
		\note On DX11 the array should be of ID3D11ShaderResourceView*, and can be passed in as Dx11Type::getPtr(srvs).
		\note On Dx12 the resources out can either be the resources or shader resource view. If you want the resources use an array of
		ID3D12Resource*, if you want the views use an array of D3D12_CPU_DESCRIPTOR_HANDLE. */
	virtual Result getTextures(InstanceId instanceId, const ETextureType* types, Int numTextures, const NvCo::ApiPtr& texturesOut) = 0;

	/*! \brief Get shader resource for attribute interpolation
		Shader attributes such as tangent, normal, etc. can be mapped to custom pixel shader.
		    This function fills SRVs necessary for such mapping.  See sample codes.
		\param [in] instanceId hair instance to get SRVs
		\param [in] types Defines the types wanted (NV_NULL for all the types of numResources should equal ShaderResourceType::COUNT_OF).
		\param [in] numResources  the size of the array that resourcesOut points to. 
		\param [out] resourcesOut array of resources (see notes)
		\note The resource returned change between each simulation and/or rendering call. Thus in general this method must be called before every use. 
		\note See EShaderResourceType for the actual resource types.
			  Use NV_HAIR_DECLARE_SHADER_RESOURCES() function in the shader to assign resource slot for each resource. 
		\note The resources out array type is dependent on the underlying rendering API being used.
		\note preRender must have been called before this method can be used, as preRender changes the values returned. stepSimulation typically does preRender by default, 
		if using Frame rate Independent Rendering (FIR) it generally will not be.
		\note On DX11 the array should be of ID3D11ShaderResourceView*, and can be passed in as Dx11Type::getPtr(srvs).
		\note On Dx12 the resources out can either be the resources or shader resource view. If you want the resources use an array of
		ID3D12Resource*, if you want the views use an array of D3D12_CPU_DESCRIPTOR_HANDLE. */
	virtual Result getShaderResources(InstanceId instanceId, const EShaderResourceType* types, Int numResources, const NvCo::ApiPtr& resourcesOut) = 0;

	/*=============================================================================================
		ANIMATION AND SIMULATION

		To move and animate hairs, a typical process is to give it an animation first, by updating 
		bones used to skin animated hair shapes.  The bone data can be either in the form of 
		standard linear matrices (Sdk.updateSkinningMatrices) or dual quaternions (Sdk.updateSkinningDqs).
		Once skinning bones are set, we call Sdk.stepSimulation() to further simulation motion of hairs for each frame.
		We allow maximum of 4 bones per each hair, see AssetDescriptor.m_boneIndices and AssetDescriptor.m_boneWeights.
	=============================================================================================*/

	/*! \brief update skinning matrices by linear matrices
		\param [in] instanceId hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the AssetDescriptor.
		\param [in] skinningMatrices array of linear skinning matrices
		\param [in] teleportMode teleport mode if any teleport option is used
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note A skinning matrix is defined as world space bone transform applied after inverse transform of the bind pose of the bone.
			When only world space bone matrix is available, one can use AssetDescriptor.m_bindPoses to get the bind pose, to construct the skinning matrix.
		\note The bone order should match the one defined in AssetDescriptor.m_boneNames.  
			The bone name can be also retrieved by Sdk.getBoneName() as well.  
			Make sure that the bone ordering is consistent between hair asset and characters used in the host application. */
	virtual Result updateSkinningMatrices( InstanceId instanceId, Int numBones, const Mat4x4* skinningMatrices, ETeleportMode teleportMode = TeleportMode::NONE) = 0;

	/*! \brief update skinning matrices by dual quaternions
		\param [in] instanceId hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the AssetDescriptor.
		\param [in] dqs array of dual quaternions.
		\param [in] teleportMode teleport mode if any teleport option is used
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result updateSkinningDqs(InstanceId	instanceId, Int numBones, const DualQuaternion* dqs, ETeleportMode teleportMode = TeleportMode::NONE) = 0;

	/*! \brief update the morph delta/s if using morph targets. Morph targets can be used alongside bones. 
		The values passed in are the delta differences between instances root positions and/or normals. 
		\param [in] instanceId hair instance to update the morph target deltas on
		\param [in] positionDeltas. SRV used as StructuredBuffer<float3>. (Can be null if positions don't need to be morphs) 
		\param [in] normalDeltas. SRV used as StructuredBuffer<float3>. The hair will be rotated from the growth mesh normal to morphed normal. (Can be null if normals don't need to be morphed)
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note On Dx11, the handles passed to positionDeltas, or normalDeltaa should be wrapped ID3D11ShaderResourceView*
		\note On Dx12, this feature is currently not implemented. Will have no effect will return NV_FAIL. */
	virtual Result updateMorphDeltas(InstanceId instanceId, const NvCo::ApiHandle& positionDeltas, const NvCo::ApiHandle& normalDeltas) = 0;

	/**
		\brief Runs simulation for all currently active hair instances for one frame.
		\details Compute GPU skinning for hair and run hair simulation for all the active hair instances.
		\param [in] timeStepSize simulation time step size in second for one frame.  Typically we sync with display fps (60).
		\param [in] worldReference This is useful when world containing hair itself is moving, but motion due to moving world is not desired and needs to be canceled out. 
		\param [in] simulateOnly If set only performs strictly simulation work, else will perform both simulation and preRender stages. If set to true, a call to preRenderHairs must be called before render methods.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note At least one simulation step must take place before rendering can take place
		\note The view should be set (via setViewProjection), before calling - as LOD alters simulation, and may not step the simulation at all */
	virtual Result stepSimulation( Float timeStepSize = 1.0f / 60.0f, const Mat4x4* worldReference = NV_NULL, Bool simulateOnly = false) = 0;
	
	/** \brief Runs simulation for a single hair instance. 
		\details Compute GPU skinning for hair and run hair simulation for all the active hair instances.
		\param [in] instanceId the instance the simulation is to be stepped on.
		\param [in] timeStep simulation time step size in second for one frame.  Typically we sync with display fps (60).
		\param [in] worldReference This is useful when world containing hair itself is moving, but motion due to moving world is not desired and needs to be canceled out.
		\param [in] simulateOnly If set only performs strictly simulation work, else will perform both simulation and preRender stages. If set to true, a call to preRenderHairs must be called before render methods.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note At least one simulation step must take place before rendering can take place 
		\note Unlike Sdk.stepSimulation this method will do a simulation step even if LOD indicates the instance is not visible */
	virtual Result stepInstanceSimulation(InstanceId instanceId, Float timeStep = 1.0f / 60.0f, const Mat4x4* worldReference = NV_NULL, Bool simulateOnly = false) = 0;

	/*! \brief Returns a conservative bounds for hairs.
		\param [in] instanceId hair instance to get the bounds information
		\param [out] bbMinOut If not NV_NULL, minimum bounds will be written here.
		\param [out] bbMaxOut If not NV_NULL, maximum bounds will be written here.
		\param [in] growthMeshOnly If true, only growth mesh bound (approximate) will be returned.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note This function is intended for approximate, but fast culling purpose.
			This does not return exact bounds, but rather conservative bounds that are guaranteed to enclose all hairs regardless of current simulation/animation changes. */
	virtual Result getBounds(InstanceId	instanceId, Vec3& bbMinOut, Vec3& bbMaxOut, Bool growthMeshOnly = false) = 0;
	
	/*! \brief Returns a conservative bounds for hairs.
		\param [in] assetId hair asset to get the bounds information
		\param [in] skinningMatrices Skinning matrices that are used to calculate bones (must match num bones defined in asset).
		\param [out] bbMinOut If not NV_NULL, minimum bounds will be written here.
		\param [out] bbMaxOut If not NV_NULL, maximum bounds will be written here.
		\param [in] growthMeshOnly If true, only growth mesh bound (approximate) will be returned.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note This function is intended for approximate, but fast culling purpose.
		This does not return exact bounds, but rather conservative bounds that are guaranteed to enclose all hairs regardless of current simulation/animation changes. */
	virtual Result getBounds(AssetId assetId, const Mat4x4* skinningMatrices, Vec3& bbMinOut, Vec3& bbMaxOut, Bool growthMeshOnly = false) = 0;

	/*! \brief Returns a conservative bounds for hairs.
		\param [in] assetId hair asset to get the bounds information
		\param [in] skinningDqs Skinning dual quaternions that are used to calculate bones (must match num bones defined in asset).
		\param [out] bbMinOut If not NV_NULL, minimum bounds will be written here.
		\param [out] bbMaxOut If not NV_NULL, maximum bounds will be written here.
		\param [in] growthMeshOnly If true, only growth mesh bound (approximate) will be returned.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note This function is intended for approximate, but fast culling purpose.
		This does not return exact bounds, but rather conservative bounds that are guaranteed to enclose all hairs regardless of current simulation/animation changes. */
	virtual Result getBounds(AssetId assetId, const DualQuaternion* skinningDqs, Vec3& bbMinOut, Vec3& bbMaxOut, Bool growthMeshOnly = false) = 0;

	/*=============================================================================================
		RENDERING HAIRS

		To render hairs, we first set global variables such as camera (Sdk.setViewProjection).
		For each hair instance, we then call Sdk.renderHairs() function to render hairs to current render target.
		\note renderHairs() call requires users to provide and properly set shaders.  See accompanying sample code.

	=============================================================================================*/
		
	/*! \brief set camera projection for rendering to a cubemap
		\param [in] viewports as applied to each view
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] visibility True if the face should be rendered to (because contents are visisble)
		\param [in] handedness The handedness used */
	virtual void setCubeMapViewProjection(const Viewport viewports[6], const Mat4x4 view[6], const Mat4x4 proj[6], const bool visibility[6], EHandednessHint handedness = HandednessHint::RIGHT) = 0;

	/*! \brief set camera projection matrices
		\param [in] viewport The viewport being rendered to
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] fov field of view in angles. Used by LOD. 
		\param [in] handedness Whether the provided view projection matrices use left handed or right handed coordinate system
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note It is important to set camera properly before rendering or simulation, 
				as most LOD controls are based on distance to the camera.
		\note Users should set proper coordinate system that matches camera definition of each rendering pass.
				Even in a single engine, different camera definitions may be used (e.g. R.H.S for view camera, L.H.S for shadow camera).
				Also, it is possible to render hairs onto multiple windows, each with differing camera setups.
				So this setting should be set in each SetViewProjection call.
				Otherwise, some functionality such as backface culling may behave incorrectly. */
	virtual Result setViewProjection(const Viewport& viewport, const Mat4x4& view, const Mat4x4& proj, EHandednessHint handedness = HandednessHint::RIGHT, Float fov = 70.0f) = 0;

	/*! \brief set previous camera projection matrices for pixel velocity attributes, etc.
		\param [in] viewport The viewport being rendered to
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\param [in] fov field of view in angles.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note It is important to set camera properly before rendering or simulation,  as most LOD controls are based on distance to the camera.
		\note Users should set proper coordinate system that matches camera definition of each rendering pass. 
				The handedness is assumed to be the same as with setViewProjection.
				Even in a single engine, different camera definitions may be used (e.g. R.H.S for view camera, L.H.S for shadow camera).
				Also, it is possible to render hairs onto multiple windows, each with differing camera setups.
				So this setting should be set in each SetViewProjection call.
				Otherwise, some functionality such as backface culling may behave incorrectly */
	virtual Result setPrevViewProjection(const Viewport& viewport, const Mat4x4& view, const Mat4x4& proj, Float fov = 70.0f) = 0;

	/*! \brief fill constant buffer for custom hair shading
		\details This function fills constant buffer data structure ShaderConstantBuffer for binding custom constant buffer in connection with custom hair pixel shader.
		\param [in] instanceId hair instance to render
		\param [out] constantBufferOut The context of provided constant buffer structure will be filled.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note setViewProjection() function should be called before using this function to get proper view/camera data in the constant buffer. */
	virtual Result prepareShaderConstantBuffer(InstanceId instanceId, ShaderConstantBuffer& constantBufferOut) = 0;

	/** \brief Performs work required before renderHairs or renderVisualization can be called (if stepSimulation is called with simulateOnly as true).
		\param [in] instanceId hair instance to preRender. 
		\param [in] simulationInterp The interpolation between previous and current simulation steps. 0 is previous, 1 is current.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\see stepSimulation.  
		\see Frame rate Independent Rendering (FIR) in documentation.
		\see As with stepSimulation m_enable must be true for preRender to function. If m_enable is false the call will do nothing, and return NV_OK
		\note If preRender has already been performed, and nothing has changed (bones/modelToWorldMatrix/simulationInterp) this call will be very fast and do nothing. */
	virtual Result preRenderInstance(InstanceId instanceId, Float simulationInterp = 1.0f) = 0;

	/** \brief Performs work required before renderHairs or renderVisualization can be called (if stepSimulation is called with simulateOnly as true).
		\param [in] simulationInterp The interpolation between previous and current simulation steps. 0 is previous simulation frame, 1 is current.
		\return Successful if NV_SUCCEEDED(Result) is true.
		\see stepSimulation.
		\see Frame rate Independent Rendering (FIR) in documentation.
		\see As with stepSimulation m_enable must be true for preRender to take place on an instance.
		\note If preRender has already been performed, and nothing has changed (bones/modelToWorldMatrix/simulationInterp) this call will be very fast and do nothing. */
	virtual Result preRender(Float simulationInterp = 1.0f) = 0;

	/** \brief render a hair instance to the current render target.
		\details This function does the main hair rendering.  
		\param [in] instanceId hair instance to render
		\param [in] shaderSettings users can customize various aspects of hair shaders using HairShaderSettings.
		\param [in] other API specific parameters needed for rendering. 
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note On Dx12 other can be a pointer to Dx12RenderInfo to define descriptors that the shader is going to use, or a custom constant buffer. 
		\note Call preRender before call if stepSimulation is called with simulateOnly = true (see FIR in documentation) */
	virtual Result renderHairs(InstanceId instanceId, const ShaderSettings* shaderSettings = NV_NULL, const NvCo::ConstApiPtr& other = NvCo::ConstApiPtr::getNull()) = 0;		

	/*! \brief render visualization functions
		\param [in] instanceId hair instance to render
		\param [in] if NV_NULL will use use default VisualizationSettings (default ctor), else will try to render with specified options.
		\details This function renders all the auxiliary visualization options given in the InstanceDescriptor.
			These can be useful for debugging and verification purposes.
			Note that not all rendering API visualization implementations can honor all of the VisualizationSettings configurations.
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note Call preRender before call if stepSimulation is called with simulateOnly = true (see FIR in documentation) 
		\note The depthOp is honored currently only for m_visualizeCullSphere, m_visualizeBoundingBox, m_visualizeCapsules options
		\note On Dx11 depthOp is also honored on m_visualizeGuideHairs,  m_visualizeSkinnedGuideHairs, m_visualizeFrames, m_visualizeShadingNormals, m_visualizeLocalPos,
		m_visualizeHairInteractions, m_visualizeControlVertices, m_visualizeGrowthMesh, m_visualizePinConstraints */
	virtual Result renderVisualization( InstanceId instanceId, const VisualizationSettings* visualizationSettings = NV_NULL) = 0;

	/*=============================================================================================
		CUSTOM MSAA FUNCTIONS

		Some engines may not have MSAA enabled render targets.
		In this case, user can use custom MSAA render targets just for HairWorks, and composite the result
		to non-msaa buffer. 
		This may be particularly useful for non-MSAA deferred rendering solutions.
	=============================================================================================*/

	/*! \brief Prepare custom MSAA buffer, and switch render target to this custom buffer.
		\param [in] sampleCount number of MSAA samples.  If 0, we simply disable msaa.
			Allowed sample counts are 1, 2, 4, 8.
		\param [in] depthCompareLess Whether depth test is 'less than' or 'greater than' for proper depth resolve.
		\param [in] other API specific parameters needed for msaa rendering.
		\return Successful if NV_SUCCEEDED(Result) is true. */	
	virtual Result startMsaaRendering(Int sampleCount, Bool depthCompareLess, const NvCo::ConstApiPtr& other = NvCo::ConstApiPtr::getNull()) = 0;

	/*! \brief Once all hairworks render calls are finished, use this function to switch back to original render target and perform MSAA resolve.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result finishMsaaRendering() = 0;
	
	/*! \brief Draw MSAA resolved color buffer to current render target.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result drawMsaaColor() = 0;

	/*! \brief Draw MSAA resolved depth buffer to current depth target.
		\param [in] emitPartialFragment when true, we write depth from partial fragment (alpha < 1.0).
		\return Successful if NV_SUCCEEDED(Result) is true. */	
	virtual Result drawMsaaPostDepth(Bool emitPartialFragment = true) = 0;

	/*=============================================================================================
		UTILITY FUNCTIONS

		Use the following functions to query further info/states of the HairWorks runtime.
		These functions are not need to just run the HairWorks, but could be useful for debugging/profiling purposes.
	=============================================================================================*/
	
	/*! \brief return information about the hairworks build. The BuildInfo structure contains functions to convert to and from strings for version numbers.
		\return The BuildInfo structure */
	virtual const BuildInfo& getBuildInfo() = 0;

	/*! \brief return number of guide hairs in the asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumGuideHairs(AssetId assetId) = 0;

	/*! \brief return number of hair vertices in the asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumHairVertices( AssetId assetId) = 0;

	/*! \brief return number of faces of the growth mesh in the asset
 		\param [in] assetId hair asset ID to use */
	virtual Int getNumFaces( AssetId assetId) = 0;

	/*! \brief get control vertices of the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] verticesOut data to copy from the asset. It should be pre-allocated to at least number of hair control vertices * sizeof(Vec3).
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getHairVertices( AssetId assetId, Vec3* verticesOut) = 0;

	/*! \brief get root vertices (growth mesh vertices) of the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] verticesOut data to copy from the asset.  It should be pre-allocated to at least number of hair curves * sizeof(Vec3).
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getRootVertices(AssetId assetId, Vec3* verticesOut) = 0;

	/*! \brief get end indices from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] indicesOut data to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getEndIndices(AssetId assetId, UInt32* indicesOut) = 0;

	/*! \brief get face indices from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] indicesOut data to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getFaceIndices(AssetId assetId, UInt32* indicesOut) = 0;

	/*! \brief get face uvs from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] uvsOut data to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getFaceUvs(AssetId assetId, Vec2* uvsOut) = 0;

	/*! \brief changes bone order based on new bone names
		This function changes bone ordering of current hair asset identified by assetID.
			In case in-game bone orders are different, or when game uses reduced number of bones compared to asset stored in .apx file,
			users can change (and optionally resave the asset) bone settings with this API.
		\param [in] assetId hair asset ID to apply bone remapping
		\param [in] boneNames bone names used in new ordering
		\param [in] numBones number of bones in new ordering
		\return Successful if NV_SUCCEEDED(Result) is true. 
		\note If original bone name from asset does not exist in new bone names, behaviors for hair vertices affected by the omitted bones can be undefined. */
	virtual Result setBoneRemapping( AssetId assetId, const Char*const*	boneNames, Int numBones) = 0;
	
	/*! \brief get number of bones used in the specified hair asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumBones(AssetId assetId) = 0;
	
	/*! \brief get bone name from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [in] boneId bone id to use
		\param [out] boneNameOut bone name gets copied into this variable.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBoneName(AssetId assetId, Int boneId, Char* boneNameOut) = 0;

	/*! \brief bind pose matrix from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [in] boneId bone id to use
		\param [out] bindPoseOut bind pose data to copy the matrix to.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBindPose(AssetId assetId, Int boneId, Mat4x4*	bindPoseOut) = 0;

	/*! \brief get bone indices from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] boneIndicesOut bone indices array to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBoneIndices(AssetId assetId, Vec4* boneIndicesOut) = 0;

	/*! \brief get bone weights from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [out] boneWeightsOut bone weights array to copy from the asset
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getBoneWeights(AssetId assetId, Vec4* boneWeightsOut) = 0;

	/*!\brief get texture file name from the specified hair asset
		\param [in] assetId hair asset ID to use
		\param [in] textureType texture type to get the name for
		\param [out] textureNameOut texture name gets copied into this variable.
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result getTextureName(AssetId assetId, ETextureType textureType, Char* textureNameOut) = 0;

	/*!\brief get number of pins used in the specified hair asset
		\param [in] assetId hair asset ID to use */
	virtual Int getNumPins(AssetId assetId) = 0;

	/*!\brief get a range of pins. startIndex + numPins <= getNumPins().
		\param [in] assetId hair asset ID to use
		\param [in] startIndex start index of pins to get in the specified hair asset's pin array
		\param [in] numPins number of pins to get
		\param [out] pinsOut pin array to copy data to */
	virtual void getPins(AssetId assetId, Int startIndex, Int numPins, Pin* pinsOut) = 0;

	/*!\brief set a range of pins. startIndex + numPins <= getNumPins().
		\param [in] assetId hair asset ID to use
		\param [in] startIndex start index of pins to set in the specified hair asset's pin array
		\param [in] numPins number of pins to set
		\param [in] pins pin array to copy data from */
	virtual void setPins(AssetId assetId, Int startIndex, Int numPins, const Pin* pins) = 0;

	/*!\brief get statistics about a hair instance
		\param[inout] asyncInOut Async handle. \see AsyncHandle to describe how the async works.
		\param[in] asyncLatest Aim to ensure latest result is returned or is inflight. \see AsyncHandle to see how async works.
		\param[in] instanceId hair instance id to pull stats from
		\param[out] statsOut pointer to HairStats struct
		\return Successful if NV_SUCCEEDED(Result) is true. */
	virtual Result computeStats(AsyncHandle* asyncInOut, Bool asyncLatest, InstanceId instanceId, Stats& statsOut) = 0;

	/*!\brief get matrix of a specified pin
		\param[inout] asyncInOut Async handle. \see AsyncHandle to describe how the async works. 
		\param[in] asyncLatest Aim to ensure latest result is returned or is inflight. \see AsyncHandle to see how async works.
		\param[in] instanceId hair instance id to specify the hair instance the specified pin belongs to
		\param[in] pinIndex index of the specified pin
		\param[out] matrixOut reference to the matrix 
		\see AsyncHandle */
	virtual Result getPinMatrix(AsyncHandle* asyncInOut, Bool asyncLatest, InstanceId instanceId, Int pinIndex, Mat4x4& matrixOut) = 0;

	/*!\brief Get matrices for multiple pins
		\param[inout] asyncInOut Async handle. \see AsyncHandle to describe how async works.
		\param[in] asyncLatest Aim to ensure latest result is returned or is inflight. \see AsyncHandle to see how async works. 
		\param[in] instanceId hair instance id to specify the hair instance the specified pin belongs to
		\param[in] startPinIndex The start pin index
		\param[in] numPins The number of pins
		\param[out] matricesOut The matrices associated with the pins *
		\see AsyncHandle */ 
	virtual Result getPinMatrices(AsyncHandle* asyncInOut, Bool asyncLatest, InstanceId instanceId, Int startPinIndex, Int numPins, Mat4x4* matricesOut) = 0;

	/*!\brief Called to inform the API that async requests identified by AsyncHandles are no longer needed
		\param[in] handles A list of handles produced by calls to the async API. They must be valid pending handles or NV_NULL 
		\param[in] numHandles The number of handles pointed to handles
		\param[in] allReferences If true all handles even if multiply referenced will be destroyed 
		\return Number of references released 
		\see AsyncHandle */
	virtual Int cancelAsync(const AsyncHandle* handles, Int numHandles, Bool allReferences) = 0;
	/*!\brief Called to inform the API that async requests on an instance are no longer needed 
	   \param[in] instId The instance to release pending async requests on
	   \param[in] allReferences If true all handles even if multiply referenced will be destroyed */
	virtual Int cancelAsync(InstanceId instId, Bool allReferences) = 0;

	/*!\brief Called to inform the API that work has been submitted to the GPU, such that resources 
	   can be managed correctly internally. With some APIs this must be called regularly (once a frame)
	   or HairWorks will leak resources. 
		\param[in] handle Api specific data applicable associated with the submission. 
		\note On Dx12 this will pass a ID3D12CommandQueue as the parameter, and should be called
		immediately after command lists have been submitted to the command queue. HairWorks will 
		insert a fence to track resource usage.
		On Dx11 this call is not needed.
		*/
	virtual Void onGpuWorkSubmitted(const NvCo::ApiHandle& handle) = 0;

	/*!\brief Can be called to request the API check the GPU state, to see what work has been completed.
	This can be used to allow HairWorks to check if async work hsa been completed.
	Note that a call to onGpuWorkSubmitted will perform an updateCompteted call, meaing generally you 
	just need to call that unless you want finer control (say to block on an async result for example).
	\note On Dx11 this method isn't needed. */
	virtual Void updateCompleted() = 0;

	/*!\brief Some APIs have to have pixel shaders configured internally, 
		and then accessed via the m_shaderIndex in the ShaderSettings parameter.
		This method is used to set up the API specific shader, on the specified index. 
		\param[in] shaderIndex The shader index.
		\param[in] pixelShader The information describing the shader
		\return Successful if NV_SUCCEEDED(Result) is true.
		\note On Dx12 this should be a Dx12PixelShaderInfo */
	virtual Result setPixelShader(Int shaderIndex, const NvCo::ConstApiPtr& pixelShader) = 0;

	/*!\brief Allows access of a set pixel shader. Only some APIs support this feature
	   \param[in] shaderIndex The shader index.
	   \param[in] pixelShaderOut A handle to receive the shader information
	   \return Successful if NV_SUCCEEDED(Result) is true. Returns NV_E_MISC_UNINITIALIZED if api supports getPixelShader, but nothing has been set.
	   \note On Dx12 this should be a Dx12PixelShaderInfo */
	virtual Result getPixelShader(Int shaderIndex, const NvCo::ApiPtr& pixelShaderOut) = 0; 
};

} // namespace HairWorks
} // namespace nvidia

/** @} */

#endif // NV_HAIR_SDK_H
